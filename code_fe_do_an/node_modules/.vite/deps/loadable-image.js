import {
  require_prop_types
} from "./chunk-774RZO6K.js";
import {
  require_jsx_runtime
} from "./chunk-U3WIRXFA.js";
import {
  _extends
} from "./chunk-5IFDVQ7W.js";
import {
  require_react_dom
} from "./chunk-G7EYRQVR.js";
import {
  require_react
} from "./chunk-4QLDQSER.js";
import {
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/loadable-image/dist/index.esm.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/react-intersection-observer/index.mjs
var React = __toESM(require_react(), 1);
var React2 = __toESM(require_react(), 1);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var observerMap = /* @__PURE__ */ new Map();
var RootIds = /* @__PURE__ */ new WeakMap();
var rootId = 0;
var unsupportedValue = void 0;
function getRootId(root) {
  if (!root)
    return "0";
  if (RootIds.has(root))
    return RootIds.get(root);
  rootId += 1;
  RootIds.set(root, rootId.toString());
  return RootIds.get(root);
}
function optionsToId(options) {
  return Object.keys(options).sort().filter(
    (key) => options[key] !== void 0
  ).map((key) => {
    return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
  }).toString();
}
function createObserver(options) {
  const id = optionsToId(options);
  let instance = observerMap.get(id);
  if (!instance) {
    const elements = /* @__PURE__ */ new Map();
    let thresholds;
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        var _a;
        const inView = entry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold);
        if (options.trackVisibility && typeof entry.isVisible === "undefined") {
          entry.isVisible = inView;
        }
        (_a = elements.get(entry.target)) == null ? void 0 : _a.forEach((callback) => {
          callback(inView, entry);
        });
      });
    }, options);
    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
    instance = {
      id,
      observer,
      elements
    };
    observerMap.set(id, instance);
  }
  return instance;
}
function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
  if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
    const bounds = element.getBoundingClientRect();
    callback(fallbackInView, {
      isIntersecting: fallbackInView,
      target: element,
      intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
      time: 0,
      boundingClientRect: bounds,
      intersectionRect: bounds,
      rootBounds: bounds
    });
    return () => {
    };
  }
  const { id, observer, elements } = createObserver(options);
  const callbacks = elements.get(element) || [];
  if (!elements.has(element)) {
    elements.set(element, callbacks);
  }
  callbacks.push(callback);
  observer.observe(element);
  return function unobserve() {
    callbacks.splice(callbacks.indexOf(callback), 1);
    if (callbacks.length === 0) {
      elements.delete(element);
      observer.unobserve(element);
    }
    if (elements.size === 0) {
      observer.disconnect();
      observerMap.delete(id);
    }
  };
}
function isPlainChildren(props) {
  return typeof props.children !== "function";
}
var InView = class extends React.Component {
  constructor(props) {
    super(props);
    __publicField(this, "node", null);
    __publicField(this, "_unobserveCb", null);
    __publicField(this, "handleNode", (node) => {
      if (this.node) {
        this.unobserve();
        if (!node && !this.props.triggerOnce && !this.props.skip) {
          this.setState({ inView: !!this.props.initialInView, entry: void 0 });
        }
      }
      this.node = node ? node : null;
      this.observeNode();
    });
    __publicField(this, "handleChange", (inView, entry) => {
      if (inView && this.props.triggerOnce) {
        this.unobserve();
      }
      if (!isPlainChildren(this.props)) {
        this.setState({ inView, entry });
      }
      if (this.props.onChange) {
        this.props.onChange(inView, entry);
      }
    });
    this.state = {
      inView: !!props.initialInView,
      entry: void 0
    };
  }
  componentDidMount() {
    this.unobserve();
    this.observeNode();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {
      this.unobserve();
      this.observeNode();
    }
  }
  componentWillUnmount() {
    this.unobserve();
  }
  observeNode() {
    if (!this.node || this.props.skip)
      return;
    const {
      threshold,
      root,
      rootMargin,
      trackVisibility,
      delay,
      fallbackInView
    } = this.props;
    this._unobserveCb = observe(
      this.node,
      this.handleChange,
      {
        threshold,
        root,
        rootMargin,
        // @ts-ignore
        trackVisibility,
        // @ts-ignore
        delay
      },
      fallbackInView
    );
  }
  unobserve() {
    if (this._unobserveCb) {
      this._unobserveCb();
      this._unobserveCb = null;
    }
  }
  render() {
    const { children: children2 } = this.props;
    if (typeof children2 === "function") {
      const { inView, entry } = this.state;
      return children2({ inView, entry, ref: this.handleNode });
    }
    const {
      as,
      triggerOnce,
      threshold,
      root,
      rootMargin,
      onChange,
      skip,
      trackVisibility,
      delay,
      initialInView,
      fallbackInView,
      ...props
    } = this.props;
    return React.createElement(
      as || "div",
      { ref: this.handleNode, ...props },
      children2
    );
  }
};

// node_modules/loadable-image/dist/index.esm.js
var import_react9 = __toESM(require_react());

// node_modules/transitions-kit/dist/index.esm.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react8 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r3, e3) {
  if (null == r3)
    return {};
  var t3 = {};
  for (var n3 in r3)
    if ({}.hasOwnProperty.call(r3, n3)) {
      if (e3.indexOf(n3) >= 0)
        continue;
      t3[n3] = r3[n3];
    }
  return t3;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t3, e3) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
    return t4.__proto__ = e4, t4;
  }, _setPrototypeOf(t3, e3);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t3, o2) {
  t3.prototype = Object.create(o2.prototype), t3.prototype.constructor = t3, _setPrototypeOf(t3, o2);
}

// node_modules/react-transition-group/esm/CSSTransition.js
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/dom-helpers/esm/hasClass.js
function hasClass(element, className) {
  if (element.classList)
    return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

// node_modules/dom-helpers/esm/addClass.js
function addClass(element, className) {
  if (element.classList)
    element.classList.add(className);
  else if (!hasClass(element, className))
    if (typeof element.className === "string")
      element.className = element.className + " " + className;
    else
      element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}

// node_modules/dom-helpers/esm/removeClass.js
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}

// node_modules/react-transition-group/esm/CSSTransition.js
var import_react3 = __toESM(require_react());

// node_modules/react-transition-group/esm/Transition.js
var import_prop_types2 = __toESM(require_prop_types());
var import_react2 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/react-transition-group/esm/config.js
var config_default = {
  disabled: false
};

// node_modules/react-transition-group/esm/utils/PropTypes.js
var import_prop_types = __toESM(require_prop_types());
var timeoutsShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
  enter: import_prop_types.default.number,
  exit: import_prop_types.default.number,
  appear: import_prop_types.default.number
}).isRequired]) : null;
var classNamesShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.shape({
  enter: import_prop_types.default.string,
  exit: import_prop_types.default.string,
  active: import_prop_types.default.string
}), import_prop_types.default.shape({
  enter: import_prop_types.default.string,
  enterDone: import_prop_types.default.string,
  enterActive: import_prop_types.default.string,
  exit: import_prop_types.default.string,
  exitDone: import_prop_types.default.string,
  exitActive: import_prop_types.default.string
})]) : null;

// node_modules/react-transition-group/esm/TransitionGroupContext.js
var import_react = __toESM(require_react());
var TransitionGroupContext_default = import_react.default.createContext(null);

// node_modules/react-transition-group/esm/utils/reflow.js
var forceReflow = function forceReflow2(node) {
  return node.scrollTop;
};

// node_modules/react-transition-group/esm/Transition.js
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
          if (node)
            forceReflow(node);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config_default.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : import_react_dom.default.findDOMNode(this);
    if (!exit || config_default.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children2 = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      import_react2.default.createElement(TransitionGroupContext_default.Provider, {
        value: null
      }, typeof children2 === "function" ? children2(status, childProps) : import_react2.default.cloneElement(import_react2.default.Children.only(children2), childProps))
    );
  };
  return Transition2;
}(import_react2.default.Component);
Transition.contextType = TransitionGroupContext_default;
Transition.propTypes = true ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: import_prop_types2.default.shape({
    current: typeof Element === "undefined" ? import_prop_types2.default.any : function(propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return import_prop_types2.default.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: import_prop_types2.default.oneOfType([import_prop_types2.default.func.isRequired, import_prop_types2.default.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: import_prop_types2.default.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: import_prop_types2.default.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: import_prop_types2.default.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: import_prop_types2.default.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: import_prop_types2.default.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: import_prop_types2.default.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener)
      pt = pt.isRequired;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return pt.apply(void 0, [props].concat(args));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: import_prop_types2.default.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: import_prop_types2.default.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: import_prop_types2.default.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: import_prop_types2.default.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: import_prop_types2.default.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: import_prop_types2.default.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: import_prop_types2.default.func
} : {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition_default = Transition;

// node_modules/react-transition-group/esm/CSSTransition.js
var _addClass = function addClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c3) {
    return addClass(node, c3);
  });
};
var removeClass2 = function removeClass3(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c3) {
    return removeClass(node, c3);
  });
};
var CSSTransition = function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass3(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node)
        forceReflow(node);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass2(node, baseClassName);
    }
    if (activeClassName) {
      removeClass2(node, activeClassName);
    }
    if (doneClassName) {
      removeClass2(node, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, _ = _this$props.classNames, props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return import_react3.default.createElement(Transition_default, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(import_react3.default.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = true ? _extends({}, Transition_default.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: import_prop_types3.default.func
}) : {};

// node_modules/react-transition-group/esm/ReplaceTransition.js
var import_prop_types5 = __toESM(require_prop_types());
var import_react6 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e3) {
  if (void 0 === e3)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e3;
}

// node_modules/react-transition-group/esm/TransitionGroup.js
var import_prop_types4 = __toESM(require_prop_types());
var import_react5 = __toESM(require_react());

// node_modules/react-transition-group/esm/utils/ChildMapping.js
var import_react4 = __toESM(require_react());
function getChildMapping(children2, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && (0, import_react4.isValidElement)(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children2)
    import_react4.Children.map(children2, function(c3) {
      return c3;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i3;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i3 = 0; i3 < nextKeysPending[nextKey].length; i3++) {
        var pendingNextKey = nextKeysPending[nextKey][i3];
        childMapping[nextKeysPending[nextKey][i3]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i3 = 0; i3 < pendingKeys.length; i3++) {
    childMapping[pendingKeys[i3]] = getValueForKey(pendingKeys[i3]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return (0, import_react4.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children2 = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children2).forEach(function(key) {
    var child = children2[key];
    if (!(0, import_react4.isValidElement)(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = (0, import_react4.isValidElement)(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children2[key] = (0, import_react4.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children2[key] = (0, import_react4.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0, import_react4.isValidElement)(prevChild)) {
      children2[key] = (0, import_react4.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children2;
}

// node_modules/react-transition-group/esm/TransitionGroup.js
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children2 = _extends({}, state.children);
        delete children2[child.key];
        return {
          children: children2
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component2 = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children2 = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component2 === null) {
      return import_react5.default.createElement(TransitionGroupContext_default.Provider, {
        value: contextValue
      }, children2);
    }
    return import_react5.default.createElement(TransitionGroupContext_default.Provider, {
      value: contextValue
    }, import_react5.default.createElement(Component2, props, children2));
  };
  return TransitionGroup2;
}(import_react5.default.Component);
TransitionGroup.propTypes = true ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: import_prop_types4.default.any,
  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: import_prop_types4.default.node,
  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: import_prop_types4.default.bool,
  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: import_prop_types4.default.bool,
  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: import_prop_types4.default.bool,
  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: import_prop_types4.default.func
} : {};
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup_default = TransitionGroup;

// node_modules/react-transition-group/esm/ReplaceTransition.js
var ReplaceTransition = function(_React$Component) {
  _inheritsLoose(ReplaceTransition2, _React$Component);
  function ReplaceTransition2() {
    var _this;
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.handleEnter = function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.handleLifecycle("onEnter", 0, args);
    };
    _this.handleEntering = function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.handleLifecycle("onEntering", 0, args);
    };
    _this.handleEntered = function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.handleLifecycle("onEntered", 0, args);
    };
    _this.handleExit = function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.handleLifecycle("onExit", 1, args);
    };
    _this.handleExiting = function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.handleLifecycle("onExiting", 1, args);
    };
    _this.handleExited = function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _this.handleLifecycle("onExited", 1, args);
    };
    return _this;
  }
  var _proto = ReplaceTransition2.prototype;
  _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;
    var children2 = this.props.children;
    var child = import_react6.default.Children.toArray(children2)[idx];
    if (child.props[handler])
      (_child$props = child.props)[handler].apply(_child$props, originalArgs);
    if (this.props[handler]) {
      var maybeNode = child.props.nodeRef ? void 0 : import_react_dom2.default.findDOMNode(this);
      this.props[handler](maybeNode);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, children2 = _this$props.children, inProp = _this$props.in, props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);
    var _React$Children$toArr = import_react6.default.Children.toArray(children2), first = _React$Children$toArr[0], second = _React$Children$toArr[1];
    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return import_react6.default.createElement(TransitionGroup_default, props, inProp ? import_react6.default.cloneElement(first, {
      key: "first",
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : import_react6.default.cloneElement(second, {
      key: "second",
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  };
  return ReplaceTransition2;
}(import_react6.default.Component);
ReplaceTransition.propTypes = true ? {
  in: import_prop_types5.default.bool.isRequired,
  children: function children(props, propName) {
    if (import_react6.default.Children.count(props[propName]) !== 2)
      return new Error('"' + propName + '" must be exactly two transition components.');
    return null;
  }
} : {};

// node_modules/react-transition-group/esm/SwitchTransition.js
var import_react7 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
var _leaveRenders;
var _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren)
    return false;
  if (import_react7.default.isValidElement(oldChildren) && import_react7.default.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }
  return true;
}
var modes = {
  out: "out-in",
  in: "in-out"
};
var callHook = function callHook2(element, name, cb) {
  return function() {
    var _element$props;
    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
    cb();
  };
};
var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(_ref) {
  var current = _ref.current, changeState = _ref.changeState;
  return import_react7.default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(_ref2) {
  var current = _ref2.current, changeState = _ref2.changeState, children2 = _ref2.children;
  return [current, import_react7.default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERING);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(_ref3) {
  var children2 = _ref3.children, changeState = _ref3.changeState;
  return import_react7.default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERED, import_react7.default.cloneElement(children2, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function(_ref4) {
  var current = _ref4.current, children2 = _ref4.children, changeState = _ref4.changeState;
  return [import_react7.default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERED, import_react7.default.cloneElement(children2, {
        in: true
      }));
    })
  }), import_react7.default.cloneElement(children2, {
    in: true
  })];
}, _enterRenders);
var SwitchTransition = function(_React$Component) {
  _inheritsLoose(SwitchTransition2, _React$Component);
  function SwitchTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: ENTERED,
      current: null
    };
    _this.appeared = false;
    _this.changeState = function(status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }
      _this.setState({
        status,
        current
      });
    };
    return _this;
  }
  var _proto = SwitchTransition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };
  SwitchTransition2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }
    if (state.status === ENTERING && props.mode === modes.in) {
      return {
        status: ENTERING
      };
    }
    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: EXITING
      };
    }
    return {
      current: import_react7.default.cloneElement(props.children, {
        in: true
      })
    };
  };
  _proto.render = function render() {
    var _this$props = this.props, children2 = _this$props.children, mode = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
    var data = {
      children: children2,
      current,
      changeState: this.changeState,
      status
    };
    var component;
    switch (status) {
      case ENTERING:
        component = enterRenders[mode](data);
        break;
      case EXITING:
        component = leaveRenders[mode](data);
        break;
      case ENTERED:
        component = current;
    }
    return import_react7.default.createElement(TransitionGroupContext_default.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };
  return SwitchTransition2;
}(import_react7.default.Component);
SwitchTransition.propTypes = true ? {
  /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */
  mode: import_prop_types6.default.oneOf([modes.in, modes.out]),
  /**
   * Any `Transition` or `CSSTransition` component.
   */
  children: import_prop_types6.default.oneOfType([import_prop_types6.default.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};

// node_modules/transitions-kit/dist/index.esm.js
function l(t3, e3) {
  var n3 = {};
  for (var i3 in t3)
    Object.prototype.hasOwnProperty.call(t3, i3) && e3.indexOf(i3) < 0 && (n3[i3] = t3[i3]);
  if (null != t3 && "function" == typeof Object.getOwnPropertySymbols) {
    var r3 = 0;
    for (i3 = Object.getOwnPropertySymbols(t3); r3 < i3.length; r3++)
      e3.indexOf(i3[r3]) < 0 && Object.prototype.propertyIsEnumerable.call(t3, i3[r3]) && (n3[i3[r3]] = t3[i3[r3]]);
  }
  return n3;
}
var d = { easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)", easeOut: "cubic-bezier(0.0, 0, 0.2, 1)", easeIn: "cubic-bezier(0.4, 0, 1, 1)", sharp: "cubic-bezier(0.4, 0, 0.6, 1)" };
var c = { shortest: 150, shorter: 200, short: 250, standard: 300, complex: 375, enteringScreen: 225, leavingScreen: 195 };
function u(t3, e3) {
  var n3, i3;
  const { timeout: r3, easing: o2, style: s3 = {} } = t3;
  return { duration: null !== (n3 = s3.transitionDuration) && void 0 !== n3 ? n3 : "number" == typeof r3 || "string" == typeof r3 ? r3 : r3[e3.mode] || 0, easing: null !== (i3 = s3.transitionTimingFunction) && void 0 !== i3 ? i3 : "object" == typeof o2 ? o2[e3.mode] : o2, delay: s3.transitionDelay };
}
var g = (t3 = ["all"], e3 = {}) => {
  const { duration: n3 = c.standard, easing: i3 = d.easeInOut, delay: r3 = 0 } = e3, o2 = (t4) => `${Math.round(t4)}ms`;
  return (Array.isArray(t3) ? t3 : [t3]).map((t4) => `${t4} ${"string" == typeof n3 ? n3 : o2(n3)} ${i3} ${"string" == typeof r3 ? r3 : o2(r3)}`).join(",");
};
var y = (t3) => {
  if (!t3)
    return 0;
  const e3 = t3 / 36;
  return Math.round(10 * (4 + 15 * Math.pow(e3, 0.25) + e3 / 5));
};
var p = (...t3) => (0, import_react8.useMemo)(() => t3.every((t4) => null == t4) ? null : (e3) => {
  t3.forEach((t4) => {
    ((t5, e4) => {
      "function" == typeof t5 ? t5(e4) : t5 && (t5.current = e4);
    })(t4, e3);
  });
}, t3);
var E = (t3, e3 = 166) => {
  let n3;
  function i3(...i4) {
    clearTimeout(n3), n3 = setTimeout(() => {
      t3.apply(this, i4);
    }, e3);
  }
  return i3.clear = () => {
    clearTimeout(n3);
  }, i3;
};
function m(t3) {
  return t3 && t3.ownerDocument || document;
}
function f(t3) {
  return m(t3).defaultView || window;
}
var h = (t3) => t3.scrollTop;
var b = { entering: { opacity: 1 }, entered: { opacity: 1 } };
var O = (0, import_react8.forwardRef)((e3, n3) => {
  const o2 = { enter: c.enteringScreen, exit: c.leavingScreen }, { addEndListener: s3, appear: d3 = true, children: y2, easing: E2, in: m3, onEnter: f2, onEntered: x, onEntering: O2, onExit: v2, onExited: j2, onExiting: w2, style: S2, timeout: $2 = o2 } = e3, T2 = l(e3, ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout"]), L2 = (0, import_react8.useRef)(null), z2 = p(y2.ref, n3), k2 = p(L2, z2), R2 = (t3) => (e4) => {
    const n4 = L2.current;
    t3 && n4 && (void 0 === e4 ? t3(n4) : t3(n4, e4));
  }, D2 = R2(O2), I2 = R2(x), H2 = R2(w2), N = R2(j2), P = R2((t3, e4) => {
    h(t3);
    const n4 = u({ style: S2, timeout: $2, easing: E2 }, { mode: "enter" });
    t3.style.webkitTransition = g("opacity", n4), t3.style.transition = g("opacity", n4), null == f2 || f2(t3, e4);
  }), A = R2((t3) => {
    const e4 = u({ style: S2, timeout: $2, easing: E2 }, { mode: "exit" });
    t3.style.webkitTransition = g("opacity", e4), t3.style.transition = g("opacity", e4), null == v2 || v2(t3);
  });
  return (0, import_jsx_runtime.jsx)(Transition_default, Object.assign({ in: m3, appear: d3, nodeRef: L2, onExit: A, onEnter: P, addEndListener: (t3) => {
    L2.current && (null == s3 || s3(L2.current, t3));
  }, onEntering: D2, onEntered: I2, onExiting: H2, onExited: N, timeout: $2 }, T2, { children: (t3) => (0, import_react8.cloneElement)(y2, { ref: k2, style: Object.assign(Object.assign(Object.assign({ opacity: 0, visibility: "exited" !== t3 || m3 ? void 0 : "hidden" }, b[t3]), S2), y2.props.style) }) }));
});
var v = (t3) => ({ entering: { opacity: 1, filter: "blur(0)" }, entered: { opacity: 1, filter: "blur(0)" }, exiting: { opacity: 0, filter: `blur(${t3}px)` }, exited: { opacity: 0, filter: `blur(${t3}px)` } });
var j = (0, import_react8.forwardRef)((e3, n3) => {
  const o2 = { enter: c.enteringScreen, exit: c.leavingScreen }, { addEndListener: s3, appear: d3 = true, children: y2, easing: E2, in: m3, radius: f2 = 25, onEnter: x, onEntered: b3, onEntering: O2, onExit: j2, onExited: w2, onExiting: S2, style: $2, timeout: T2 = o2 } = e3, L2 = l(e3, ["addEndListener", "appear", "children", "easing", "in", "radius", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout"]), z2 = (0, import_react8.useRef)(null), k2 = p(y2.ref, n3), R2 = p(z2, k2), D2 = (t3) => (e4) => {
    const n4 = z2.current;
    t3 && n4 && (void 0 === e4 ? t3(n4) : t3(n4, e4));
  }, I2 = D2(O2), H2 = D2(b3), N = D2(S2), P = D2(w2), A = D2((t3, e4) => {
    h(t3);
    const n4 = u({ style: $2, timeout: T2, easing: E2 }, { mode: "enter" });
    t3.style.webkitTransition = g(["opacity", "filter"], n4), t3.style.transition = g(["opacity", "filter"], n4), null == x || x(t3, e4);
  }), F = D2((t3) => {
    const e4 = u({ style: $2, timeout: T2, easing: E2 }, { mode: "exit" });
    t3.style.webkitTransition = g(["opacity", "filter"], e4), t3.style.transition = g(["opacity", "filter"], e4), null == j2 || j2(t3);
  });
  return (0, import_jsx_runtime.jsx)(Transition_default, Object.assign({ in: m3, appear: d3, nodeRef: z2, onExit: F, onEnter: A, addEndListener: (t3) => {
    z2.current && (null == s3 || s3(z2.current, t3));
  }, onEntering: I2, onEntered: H2, onExiting: N, onExited: P, timeout: T2 }, L2, { children: (t3) => (0, import_react8.cloneElement)(y2, { ref: R2, style: Object.assign(Object.assign(Object.assign({ opacity: 0, visibility: "exited" !== t3 || m3 ? void 0 : "hidden" }, v(f2)[t3]), $2), y2.props.style) }) }));
});
var w = (0, import_react8.forwardRef)(({ children: e3, ownerState: n3, style: i3 = {} }, r3) => (0, import_jsx_runtime.jsx)("div", { ref: r3, style: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, i3), { height: 0, overflow: "hidden", transition: g("height") }), "horizontal" === n3.orientation && { height: "auto", width: 0, transition: g("width") }), "entered" === n3.state && Object.assign({ height: "auto", overflow: "visible" }, "horizontal" === n3.orientation && { width: "auto" })), "exited" === n3.state && !n3.in && "0px" === n3.collapsedSize && { visibility: "hidden" }), children: e3 }));
var S = (0, import_react8.forwardRef)(({ children: e3, ownerState: n3, style: i3 }, r3) => (0, import_jsx_runtime.jsx)("div", { ref: r3, style: Object.assign({ display: "flex", width: "100%" }, "horizontal" === n3.orientation && { width: "auto", height: "100%" }), children: e3 }));
var $ = ({ children: e3, ownerState: n3 }) => (0, import_jsx_runtime.jsx)("div", { style: Object.assign({ width: "100%" }, "horizontal" === n3.orientation && { width: "auto", height: "100%" }), children: e3 });
var T = (0, import_react8.forwardRef)((e3, n3) => {
  const { addEndListener: r3, children: s3, className: d3, collapsedSize: g3 = "0px", easing: E2, in: m3, onEnter: f2, onEntered: x, onEntering: b3, onExit: O2, onExited: v2, onExiting: j2, orientation: T2 = "vertical", style: L2, timeout: z2 = c.standard } = e3, k2 = l(e3, ["addEndListener", "children", "className", "collapsedSize", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "orientation", "style", "timeout"]), R2 = Object.assign(Object.assign({}, e3), { orientation: T2, collapsedSize: g3 }), D2 = (0, import_react8.useRef)(), I2 = (0, import_react8.useRef)(null), H2 = p(I2, n3), N = (0, import_react8.useRef)(null), P = (0, import_react8.useRef)(), A = "number" == typeof g3 ? `${g3}px` : g3, F = "horizontal" === T2, X = F ? "width" : "height";
  (0, import_react8.useEffect)(() => () => {
    clearTimeout(D2.current);
  }, []);
  const Y = (t3) => (e4) => {
    const n4 = I2.current;
    t3 && n4 && (void 0 === e4 ? t3(n4) : t3(n4, e4));
  }, C = () => N.current ? N.current[F ? "scrollWidth" : "scrollHeight"] : 0, M = Y((t3, e4) => {
    t3.style[X] = A, null == f2 || f2(t3, e4);
  }), V = Y((t3, e4) => {
    const n4 = C(), { duration: i3, easing: r4 } = u({ style: L2, timeout: z2, easing: E2 }, { mode: "enter" });
    if ("auto" === z2) {
      const e5 = y(n4);
      t3.style.transitionDuration = `${e5}ms`, P.current = e5;
    } else
      t3.style.transitionDuration = "string" == typeof i3 ? i3 : `${i3}ms`;
    t3.style[X] = `${n4}px`, t3.style.transitionTimingFunction = `${r4}`, null == b3 || b3(t3, e4);
  }), W = Y((t3, e4) => {
    t3.style[X] = "auto", null == x || x(t3, e4);
  }), B = Y((t3) => {
    t3.style[X] = `${C()}px`, N.current && h(N.current), null == O2 || O2(t3);
  }), _ = Y((t3) => {
    const e4 = C(), { duration: n4, easing: i3 } = u({ style: L2, timeout: z2, easing: E2 }, { mode: "exit" });
    if ("auto" === z2) {
      const n5 = y(e4);
      t3.style.transitionDuration = `${n5}ms`, P.current = n5;
    } else
      t3.style.transitionDuration = "string" == typeof n4 ? n4 : `${n4}ms`;
    t3.style[X] = A, t3.style.transitionTimingFunction = null != i3 ? i3 : "", null == j2 || j2(t3);
  }), q = Y(v2);
  return (0, import_jsx_runtime.jsx)(Transition_default, Object.assign({ in: m3, nodeRef: I2, onEnter: M, onEntered: W, onEntering: V, onExit: B, onExited: q, onExiting: _, addEndListener: (t3) => {
    "auto" === z2 && (D2.current = window.setTimeout(t3, Number(P.current) || 0)), I2.current && (null == r3 || r3(I2.current, t3));
  }, timeout: "auto" === z2 ? void 0 : z2 }, k2, { children: (e4) => (0, import_jsx_runtime.jsx)(w, { ref: H2, ownerState: Object.assign(Object.assign({}, R2), { state: e4 }), style: Object.assign({ [F ? "minWidth" : "minHeight"]: A }, L2), children: (0, import_jsx_runtime.jsx)(S, { ownerState: Object.assign(Object.assign({}, R2), { state: e4 }), ref: N, children: (0, import_jsx_runtime.jsx)($, { ownerState: Object.assign(Object.assign({}, R2), { state: e4 }), children: s3 }) }) }) }));
});
function L(t3, e3, n3) {
  var i3;
  const r3 = function(t4, e4, n4) {
    const i4 = e4.getBoundingClientRect(), r4 = null == n4 ? void 0 : n4.getBoundingClientRect(), o2 = f(e4), s3 = o2.getComputedStyle(e4), a = s3.getPropertyValue("-webkit-transform") || s3.getPropertyValue("transform");
    let l3 = 0, d3 = 0;
    if (a && "none" !== a && "string" == typeof a) {
      const t5 = a.split("(")[1].split(")")[0].split(",");
      l3 = parseInt(t5[4], 10), d3 = parseInt(t5[5], 10);
    }
    return "left" === t4 ? r4 ? `translateX(${r4.right + l3 - i4.left}px)` : `translateX(${o2.innerWidth + l3 - i4.left}px)` : "right" === t4 ? r4 ? `translateX(-${i4.right - r4.left - l3}px)` : `translateX(-${i4.left + i4.width - l3}px)` : "up" === t4 ? r4 ? `translateY(${r4.bottom + d3 - i4.top}px)` : `translateY(${o2.innerHeight + d3 - i4.top}px)` : r4 ? `translateY(-${i4.top - r4.top + i4.height - d3}px)` : `translateY(-${i4.top + i4.height - d3}px)`;
  }(t3, e3, "function" == typeof (i3 = n3) ? i3() : i3);
  r3 && (e3.style.webkitTransform = r3, e3.style.transform = r3);
}
var z = (0, import_react8.forwardRef)((e3, n3) => {
  const y2 = { enter: d.easeOut, exit: d.sharp }, m3 = { enter: c.enteringScreen, exit: c.leavingScreen }, { addEndListener: x, appear: b3 = true, children: O2, container: v2, direction: j2 = "down", easing: w2 = y2, in: S2, onEnter: $2, onEntered: T2, onEntering: z2, onExit: k2, onExited: R2, onExiting: D2, style: I2, timeout: H2 = m3 } = e3, N = l(e3, ["addEndListener", "appear", "children", "container", "direction", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout"]), P = (0, import_react8.useRef)(void 0), A = p(O2.ref, P), F = p(A, n3), X = (t3) => (e4) => {
    const n4 = P.current;
    t3 && n4 && (void 0 === e4 ? t3(n4) : t3(n4, e4));
  }, Y = X((t3, e4) => {
    L(j2, t3, v2), h(t3), null == $2 || $2(t3, e4);
  }), C = X((t3, e4) => {
    const n4 = u({ timeout: H2, style: I2, easing: w2 }, { mode: "enter" });
    t3.style.webkitTransition = g("-webkit-transform", n4), t3.style.transition = g("transform", n4), t3.style.webkitTransform = "none", t3.style.transform = "none", null == z2 || z2(t3, e4);
  }), M = X((t3) => {
    const e4 = u({ timeout: H2, style: I2, easing: w2 }, { mode: "exit" });
    t3.style.webkitTransition = g("-webkit-transform", e4), t3.style.transition = g("transform", e4), L(j2, t3, v2), null == k2 || k2(t3);
  }), V = X((t3) => {
    t3.style.webkitTransition = "", t3.style.transition = "", null == R2 || R2(t3);
  }), W = (0, import_react8.useCallback)(() => {
    P.current && L(j2, P.current, v2);
  }, [j2, v2]);
  return (0, import_react8.useEffect)(() => {
    if (S2 || "down" === j2 || "right" === j2)
      return;
    const t3 = E(() => {
      P.current && L(j2, P.current, v2);
    }), e4 = f(P.current);
    return e4.addEventListener("resize", t3), () => {
      t3.clear(), e4.removeEventListener("resize", t3);
    };
  }, [j2, S2, v2]), (0, import_react8.useEffect)(() => {
    S2 || W();
  }, [S2, W]), (0, import_jsx_runtime.jsx)(Transition_default, Object.assign({ in: S2, appear: b3, nodeRef: P, timeout: H2, onEnter: Y, onEntered: T2, onEntering: C, onExit: M, onExited: V, onExiting: D2, addEndListener: (t3) => {
    P.current && (null == x || x(P.current, t3));
  } }, N, { children: (t3) => (0, import_react8.cloneElement)(O2, { ref: F, style: Object.assign(Object.assign({ visibility: "exited" !== t3 || S2 ? void 0 : "hidden" }, I2), O2.props.style) }) }));
});
var k = { entering: { transform: "none" }, entered: { transform: "none" } };
var R = (0, import_react8.forwardRef)((e3, n3) => {
  const o2 = { enter: c.enteringScreen, exit: c.leavingScreen }, { addEndListener: s3, appear: d3 = true, children: y2, easing: E2, in: m3, onEnter: f2, onEntered: x, onEntering: b3, onExit: O2, onExited: v2, onExiting: j2, style: w2, timeout: S2 = o2 } = e3, $2 = l(e3, ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout"]), T2 = (0, import_react8.useRef)(null), L2 = p(y2.ref, n3), z2 = p(T2, L2), R2 = (t3) => (e4) => {
    const n4 = T2.current;
    t3 && n4 && (void 0 === e4 ? t3(n4) : t3(n4, e4));
  }, D2 = R2(x), I2 = R2(b3), H2 = R2(v2), N = R2(j2), P = R2((t3, e4) => {
    h(t3);
    const n4 = u({ style: w2, timeout: S2, easing: E2 }, { mode: "enter" });
    t3.style.webkitTransition = g("transform", n4), t3.style.transition = g("transform", n4), null == f2 || f2(t3, e4);
  }), A = R2((t3) => {
    const e4 = u({ style: w2, timeout: S2, easing: E2 }, { mode: "exit" });
    t3.style.webkitTransition = g("transform", e4), t3.style.transition = g("transform", e4), null == O2 || O2(t3);
  });
  return (0, import_jsx_runtime.jsx)(Transition_default, Object.assign({ in: m3, appear: d3, nodeRef: T2, onEnter: P, onEntered: D2, onEntering: I2, onExit: A, onExited: H2, onExiting: N, addEndListener: (t3) => {
    T2.current && (null == s3 || s3(T2.current, t3));
  }, timeout: S2 }, $2, { children: (t3) => (0, import_react8.cloneElement)(y2, { ref: z2, style: Object.assign(Object.assign(Object.assign({ transform: "scale(0)", visibility: "exited" !== t3 || m3 ? void 0 : "hidden" }, k[t3]), w2), y2.props.style) }) }));
});
var D = { entering: { opacity: 1, transform: "scale(1)" }, entered: { opacity: 1, transform: "none" } };
var I = "undefined" != typeof navigator && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
var H = (0, import_react8.forwardRef)((e3, n3) => {
  const { addEndListener: s3, appear: d3 = true, children: c3, easing: E2, in: m3, onEnter: f2, onEntered: x, onEntering: b3, onExit: O2, onExited: v2, onExiting: j2, style: w2, timeout: S2 = "auto" } = e3, $2 = l(e3, ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout"]), T2 = (0, import_react8.useRef)(), L2 = (0, import_react8.useRef)(), z2 = (0, import_react8.useRef)(null), k2 = p(c3.ref, n3), R2 = p(z2, k2), H2 = (t3) => (e4) => {
    const n4 = z2.current;
    t3 && n4 && (void 0 === e4 ? t3(n4) : t3(n4, e4));
  }, N = H2(x), P = H2(b3), A = H2(v2), F = H2(j2), X = H2((t3, e4) => {
    h(t3);
    const { duration: n4, delay: i3, easing: r3 } = u({ style: w2, timeout: S2, easing: E2 }, { mode: "enter" });
    let o2;
    "auto" === S2 ? (o2 = y(t3.clientHeight), L2.current = o2) : o2 = n4, t3.style.transition = [g("opacity", { duration: o2, delay: i3 }), g("transform", { duration: I || "string" == typeof o2 ? o2 : 0.666 * o2, delay: i3, easing: r3 })].join(","), null == f2 || f2(t3, e4);
  }), Y = H2((t3) => {
    const { duration: e4, delay: n4, easing: i3 } = u({ style: w2, timeout: S2, easing: E2 }, { mode: "exit" });
    let r3;
    "auto" === S2 ? (r3 = y(t3.clientHeight), L2.current = r3) : r3 = e4, t3.style.transition = [g("opacity", { duration: r3, delay: n4 }), g("transform", { duration: I || "string" == typeof r3 ? r3 : 0.666 * r3, delay: I || "string" == typeof r3 ? n4 : n4 || 0.333 * r3, easing: i3 })].join(","), t3.style.opacity = "0", t3.style.transform = "scale(0.75)", null == O2 || O2(t3);
  });
  return (0, import_react8.useEffect)(() => () => {
    clearTimeout(T2.current);
  }, []), (0, import_jsx_runtime.jsx)(Transition_default, Object.assign({ in: m3, appear: d3, nodeRef: z2, onEnter: X, onEntered: N, onEntering: P, onExit: Y, onExited: A, onExiting: F, addEndListener: (t3) => {
    "auto" === S2 && (T2.current = window.setTimeout(t3, L2.current || 0)), z2.current && (null == s3 || s3(z2.current, t3));
  }, timeout: "auto" === S2 ? void 0 : S2 }, $2, { children: (t3) => (0, import_react8.cloneElement)(c3, { ref: R2, style: Object.assign(Object.assign(Object.assign({ opacity: 0, transform: "scale(0.75)", visibility: "exited" !== t3 || m3 ? void 0 : "hidden" }, D[t3]), w2), c3.props.style) }) }));
});

// node_modules/loadable-image/dist/index.esm.js
function c2(e3, r3) {
  var t3 = {};
  for (var o2 in e3)
    Object.prototype.hasOwnProperty.call(e3, o2) && r3.indexOf(o2) < 0 && (t3[o2] = e3[o2]);
  if (null != e3 && "function" == typeof Object.getOwnPropertySymbols) {
    var i3 = 0;
    for (o2 = Object.getOwnPropertySymbols(e3); i3 < o2.length; i3++)
      r3.indexOf(o2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(e3, o2[i3]) && (t3[o2[i3]] = e3[o2[i3]]);
  }
  return t3;
}
var l2 = (0, import_react9.forwardRef)((r3, t3) => {
  var { style: o2 } = r3, i3 = c2(r3, ["style"]);
  return (0, import_jsx_runtime2.jsx)("div", Object.assign({ ref: t3 }, i3, { className: `AsyncImage-root ${i3.className}`.trim(), style: Object.assign(Object.assign({}, o2), { display: "flex", overflow: "hidden", backgroundRepeat: "no-repeat", boxSizing: "border-box", backgroundSize: "cover", position: "relative" }) }));
});
var b2 = { top: 0, left: 0, width: "100%", height: "100%", position: "absolute", boxSizing: "border-box" };
var d2 = (0, import_jsx_runtime2.jsx)("div", { className: "AsyncImage-loader", style: { backgroundColor: "#eee" } });
var p2 = (0, import_jsx_runtime2.jsx)("div", { className: "Asyncimage-error", style: { backgroundColor: "#eee" }, children: (0, import_jsx_runtime2.jsx)("svg", { fill: "#00000061", viewBox: "0 0 24 24", style: { position: "absolute", inset: 0, width: "50%", height: "50%", margin: "auto" }, children: (0, import_jsx_runtime2.jsx)("path", { d: "M21 5c0-1.1-.9-2-2-2H5.83L21 18.17V5zM2.81 2.81 1.39 4.22 3 5.83V19c0 1.1.9 2 2 2h13.17l1.61 1.61 1.41-1.41L2.81 2.81zM6 17l3-4 2.25 3 .82-1.1 2.1 2.1H6z" }) }) });
var u2;
!function(e3) {
  e3[e3.LOADING = 0] = "LOADING", e3[e3.LOADED = 1] = "LOADED", e3[e3.FAILED = 2] = "FAILED";
}(u2 || (u2 = {}));
var g2 = (o2) => {
  var { error: i3, loader: l3, onLoad: d3, onError: p3, objectFit: g3 = "cover", Transition: m3 = O, sources: O2 = [], inView: y2 } = o2, j2 = c2(o2, ["error", "loader", "onLoad", "onError", "objectFit", "Transition", "sources", "inView"]);
  const [f2, h2] = (0, import_react9.useState)(u2.LOADING);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(O, { appear: false, in: f2 === u2.LOADING, timeout: 1e3, unmountOnExit: true, children: (0, import_react9.cloneElement)(l3, { style: Object.assign(Object.assign({}, l3.props.style), b2) }) }), y2 && (0, import_jsx_runtime2.jsx)(m3, { in: f2 === u2.LOADED, timeout: 1e3, children: (0, import_jsx_runtime2.jsxs)("picture", { style: b2, children: [O2.map((r3) => (0, import_jsx_runtime2.jsx)("source", Object.assign({}, r3), r3.srcSet)), (0, import_jsx_runtime2.jsx)("img", Object.assign({}, j2, { className: "AsyncImage-image", style: Object.assign({ objectFit: g3 }, b2), onLoad: (e3) => {
    h2(u2.LOADED), null == d3 || d3(e3);
  }, onError: (e3) => {
    h2(u2.FAILED), null == p3 || p3(e3);
  } }))] }) }), (0, import_jsx_runtime2.jsx)(m3, { in: f2 === u2.FAILED, timeout: 1e3, mountOnEnter: true, unmountOnExit: true, children: (0, import_react9.cloneElement)(i3, { style: Object.assign(Object.assign({}, i3.props.style), b2) }) })] });
};
var m2 = (r3) => {
  var { loader: t3 = d2, error: i3 = p2, rootMargin: n3 = "600px 0px", objectFit: s3 = "cover", style: a = {}, className: b3 = "" } = r3, u3 = c2(r3, ["loader", "error", "rootMargin", "objectFit", "style", "className"]);
  return (0, import_jsx_runtime2.jsx)(InView, { rootMargin: n3, triggerOnce: true, children: ({ ref: r4, inView: o2 }) => {
    var n4;
    return (0, import_jsx_runtime2.jsx)(l2, { ref: r4, className: b3, style: a, children: (0, import_jsx_runtime2.jsx)(g2, Object.assign({ error: i3, loader: t3, objectFit: null !== (n4 = a.objectFit) && void 0 !== n4 ? n4 : s3, inView: o2 }, u3)) });
  } });
};
export {
  m2 as AsyncImage
};
//# sourceMappingURL=loadable-image.js.map
